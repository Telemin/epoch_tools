#!/usr/bin/env python2

import epochtools_common as ec
import sdf
import pickle

import signal
import argparse
import multiprocessing as mp
import os
from distutils import spawn

import numpy as np
import math as m
import scipy as sp
import scipy.constants as const
import matplotlib
matplotlib.use('Agg')  
from matplotlib.colors import LogNorm
from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib.pyplot as plt

def init_worker():
  signal.signal(signal.SIGINT, signal.SIG_IGN)


def rough_gradient(xIterable, yIterable):
  gradient = [0]

  for i in range(1, len(xIterable) - 1):
    dx = 0.5*((xIterable[i+1] + xIterable[i]) - (xIterable[i] + xIterable[i-1]))
    dy = 0.5*((yIterable[i+1] + yIterable[i]) - (yIterable[i] + yIterable[i-1]))
    gradient.append(dy)

  gradient.append(0)
  #gradient.append(iterable[-1] - midpoint)/(stepSize/2))
  
  return gaussian_smooth_extended(gradient,16)
    

def gaussian_smooth_extended(data,degree=5):  

  data = np.array(data)
  window=degree*2-1  
  weight=np.array([1.0]*window)  
  weightGauss=[]
  data = np.append(data, np.array([data[-1]]*(degree-1)))
  data = np.append(np.array([data[0]]*(degree-1)), data)

  for i in range(window):  

    i=i-degree+1  

    frac=i/float(window)  

    gauss=1/(np.exp((4*(frac))**2))  

    weightGauss.append(gauss)  

  weight=np.array(weightGauss)*weight  

  smoothed=[0.0]*(len(data)-window+1)  

  for i in range(len(smoothed)):  

    smoothed[i]=sum(np.array(data[i:i+window])*weight)/sum(weight)  

  return np.array(smoothed)


def local_argmax(iterable, start, window):
  if type(start) != int:
    raise TypeError("start must be of type int")
  if type(window) != int:
    raise TypeError("window must be of type int")

  if start < 0:
    start += len(iterable)

  ## TODO finish me  


def argument_parse():
  parser = argparse.ArgumentParser(description='Find density FFT')
  parser.set_defaults(outputdir='vg_tracking')
  parser.add_argument('--ires', dest="ires", type=int, nargs=2)
  parser.add_argument('--clim', dest='clim', type=float, nargs=2,
    metavar=("cmin", "cmax"), help='limits of colour axis')
  parser.add_argument('--nprocs', '-n', type=int, dest='procs', default=1)
  return(parser.parse_args())


def smooth(x,beta):
 """ kaiser window smoothing """
 window_len=11
 # extending the data at beginning and at the end
 # to apply the window at the borders
 s = np.r_[x[window_len-1:0:-1],x,x[-1:-window_len:-1]]
 w = np.kaiser(window_len,beta)
 y = np.convolve(w/w.sum(),s,mode='valid')
 return y[5:len(y)-5]


def find_zero_crossing(data, start=0, stop=-1):
#  if type(direction) != int:
#    raise TypeError("Error: direction: expected int, not {0}".format(type(direction)))
#  if type(start) != int:
#    raise TypeError("Error: start: expected int, not {0}".format(type(start)))
  
  direction = -1 if ( start > stop and stop > -1) else 1

  for i in range(start, stop, direction):
    if (data[i] * data[i+1]) < 0:
      return(i)

  return(-1)

def interpolate_crossing(a, b):
  m = (b[1] - a[1]) / (b[0] - a[0])
  c = a[1] - (a[0] * m)
  print("\t interpolation debug:")
  print("\t a: {0} \n \t b: {1}".format(a,b))
  print("\t m: {0}".format(m))
  if m != 0:
    zero = - (c/m)
  else:
    zero = a[0]
  print("\t zero: {0}".format(zero))
  return(zero)

def extract_zero_point(filename):
 
  FileInUse = ec.check_file_in_use(filename)
  if FileInUse:
    print("{0} in use by PID {1}, skipping".format(filename,FileInUse))
    return
  elif os.path.exists(os.path.join(os.getcwd(),args.outputdir,''.join((filename[:-4],'.png')))):
    print("{0} already analyzed, skipping".format(filename))
    return
  else:
    print("Analyzing {0}".format(filename))

 
  try:
    filedata = sdf.SDF(filename).read()
    x = filedata['Grid/Grid/X']
    y = filedata['Grid/Grid/Y']
    ex = filedata['Electric Field/Ex'].transpose()
    dens = filedata['Derived/Number_Density'].transpose()
  except:
    print("Problem analyzing {0}, file corrupted or missing data".format(filename))
    return

  ymin_loc = np.abs(y).argmin()
  lineout_ex = ex[ymin_loc]
  slineout_ex = lineout_ex
  time = filedata['Header']['time']
  exargmin = np.argmin(lineout_ex)
  exarg0 = find_zero_crossing(lineout_ex, exargmin, 0)
  print("crossing x:",x[exarg0], x[exarg0+1])
  print("crossing ex:",lineout_ex[exarg0], lineout_ex[exarg0+1])
  ex0 = lineout_ex[exarg0]
  #x0 = x[exarg0]
  x0 = interpolate_crossing((x[exarg0],lineout_ex[exarg0]),(x[exarg0+1],lineout_ex[exarg0+1]))
  y0 = y[ymin_loc]

  print("Zero in {0} at idx {1}: ({2},{3})".format(filename, exarg0, x0,y0))
 
  cmin = args.limits[0] if args.clim else dens.min()
  cmax = args.limits[1] if args.clim else dens.max()

  plt.figure()
  ax = []
  ax.append(plt.subplot2grid((1,1), (0,0)))
  ax.append(ax[0].twinx())	
  im = []
#  im.append(ax[0].imshow(dens[::10,::10], vmin=cmin, vmax=cmax, norm=LogNorm(),
#            extent=[x.min(), x.max(), y.min(), y.max()], aspect='auto'))
  grads = rough_gradient(x, lineout_ex)
  im.append(ax[0].plot(x,slineout_ex))
  im.append(ax[0].plot(x0,0,'k.',markersize=9))
  im.append(ax[0].plot(x[exarg0],lineout_ex[exarg0],'k+',markersize=9))
  im.append(ax[1].plot(x,grads, color='g'))
  
  axLim = [abs(slineout_ex.min()) if abs(slineout_ex.min()) > abs(lineout_ex.max()) else abs(slineout_ex.max())]
  axLim.append(abs(grads.min()) if abs(grads.min()) > abs(grads.max()) else abs(grads.max()))
  ax[0].set_ylim(-axLim[0],axLim[0])
  ax[1].set_ylim(-axLim[1],axLim[1])

#  divider = make_axes_locatable(ax[0])
#  cax = divider.append_axes('right', size='5%', pad=0.05)
#  plt.colorbar(im[0], cax=cax)
  x_px = args.ires[0] if args.ires else 1440
  y_px = args.ires[1] if args.ires else 900
  y_size=10
  x_size=y_size*x_px / y_px
  plt.gcf().set_size_inches(x_size,y_size)
  savepath = os.path.join(args.outputdir,(filename[:-4]))
  plt.savefig(savepath,dpi=x_px/x_size)
  plt.close()


  return((x0, time))
 

def main():
  global args
  args = argument_parse()

  print("Re-analyzing all files...\n")
  ec.force_mkdir(args.outputdir) 
 

  sdf_list = [f for f in os.listdir(os.getcwd()) if f.endswith('.sdf')]

  workerPool = mp.Pool(args.procs, init_worker)

  try:
#    zeropoints = workerPool.map_async(extract_zero_point, sdf_list).get(999999)
    zeropoints = map(extract_zero_point, sdf_list)
    workerPool.close()
    workerPool.join()

  except KeyboardInterrupt:
    print "Caught keyboard interrupt, terminating..."
    workerPool.terminate()
    workerpool.join()

  zeropoints = filter(None, zeropoints)

  zeropoints.sort(key=lambda tup: tup[1])
  
  with open('zeropoints.pickle' ,'wb') as f:
    pickle.dump(zeropoints, f)

  gammas = []
  vs = []
  for i in range(0,len(zeropoints)-2):
    tstep = zeropoints[i][1] - zeropoints[i-1][1]
    xstep = zeropoints[i][0] - zeropoints[i-1][0]
    vstep = xstep / tstep
    vs.append((zeropoints[i][0],vstep))
    try:
      gammastep = 1 / m.sqrt(1- m.pow(vstep/const.c, 2))
      gammas.append((zeropoints[i][0],gammastep))
    except:
      gammastep = "invalid"

    print("Est vel at step {0}: {1} m/s, gamma - {2}".format(i, vstep, gammastep))
 
  x0s, gammas = zip(*gammas)
  xs, vs = zip(*vs)
  s = si.UnivariateSpline(xs
  


  plt.figure()
  ax = []
  ax.append(plt.subplot2grid((1,1), (0,0)))
  im = []
  im.append(ax[0].plot(xs,'k.',markersize=9))
  x_px = args.ires[0] if args.ires else 1440
  y_px = args.ires[1] if args.ires else 900
  y_size=10
  x_size=y_size*x_px / y_px
  plt.gcf().set_size_inches(x_size,y_size)
  savepath = 'xs'
  plt.savefig(savepath,dpi=x_px/x_size)
  plt.close()


  plt.figure()
  ax = []
  ax.append(plt.subplot2grid((1,1), (0,0)))
  im = []
  im.append(ax[0].plot(xs, vs,'k.',markersize=9))
  im.append(ax[0].axhline(y=3e8))
  ax[0].set_ylim(0,1e9)
  x_px = args.ires[0] if args.ires else 1440
  y_px = args.ires[1] if args.ires else 900
  y_size=10
  x_size=y_size*x_px / y_px
  plt.gcf().set_size_inches(x_size,y_size)
  savepath = 'vs'
  plt.savefig(savepath,dpi=x_px/x_size)
  plt.close()

  plt.figure()
  ax = []
  ax.append(plt.subplot2grid((1,1), (0,0)))
  im = []
  im.append(ax[0].plot(x0s, gammas,'k.',markersize=9))
  x_px = args.ires[0] if args.ires else 1440
  y_px = args.ires[1] if args.ires else 900
  y_size=10
  x_size=y_size*x_px / y_px
  plt.gcf().set_size_inches(x_size,y_size)
  savepath = 'gammas'
  plt.savefig(savepath,dpi=x_px/x_size)
  plt.close()


if __name__ == '__main__':
  main()
