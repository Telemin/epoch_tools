#!/usr/bin/env python2

import re
import multiprocessing as mp
import os
import sys
import shutil
from distutils import spawn
import argparse
import functools

import epochtools_common as ec

import matplotlib
matplotlib.use('Agg')  
from matplotlib.colors import LogNorm, SymLogNorm
from mpl_toolkits.axes_grid1 import make_axes_locatable
import matplotlib.pyplot as plt
import numpy as np
import sdf

def argument_parse():

# Set up parser and global options
  parser = argparse.ArgumentParser(description='Find density FFT')
  parser.add_argument('--exclude','-e',dest='exclude',action='append',
    metavar="patt", help="exclude filenames matching regex 'patt', " 
    "may be used more than once")
  parser.add_argument('--freshen','-f', dest='freshen', action='store_true',
    help="Re-analyze all files")
  parser.add_argument('--ires', '-i', dest='ires', type=int, nargs=2,
    metavar=(r'x(px)', r'y(px)'), help='Output image dimensions (px)')
  parser.add_argument('--numprocs','-n', dest='procs', type=int, default=1,
    help="Number of analysis threads to use")
  parser.add_argument('--window-clip','-c',dest='clip', type=float, nargs=4,
    metavar=("xmin","xmax","ymin","ymax"), help="Clip total window size, (expressed as"
    "fractional position, from bottom right)")
  parser.add_argument('--verbose','-v', action='store_true',
    help="give verbose (debugging) output")
  parser.add_argument('--single', '-s', dest='single', type=str,
    metavar="filename", help="analyse single file")
  parser.add_argument('--movie','-m', dest='movie', action='store_true',
    help="create movie using all available files, (default)")
  parser.add_argument('--outputprefix','-p',dest='outputPrefix',type=str,
    metavar="prefix", help="prefix to apply to output file(s)")
  parser.add_argument('--outputdir','-d',dest='outputDir',type=str,
    metavar="dir", help="directory to hold output files, defaults to {mode}")

# Define subparser handler
  subparsers = parser.add_subparsers(help="Modes",dest='mode')

#Density mode
  density = subparsers.add_parser('density',help="Analyze electron density")
  density.set_defaults(imgfunc=density_image)
  density.add_argument('--logscale',action='store_true', 
    help="log scale output")  
  density.add_argument('--clim', dest='limits', type=float, nargs=2,
    metavar=("cmin", "cmax"), help='limits of colour axis')

#ex mode
  ex = subparsers.add_parser('ex',help="Analyze ex")
  ex.set_defaults(imgfunc=ex_image)
  ex.add_argument('--clim', dest='limits', type=float, nargs=2,
   metavar=("cmin", "cmax"), help='limits of colour axis')
  ex.add_argument('--slogscale', dest='slogscale', type=float, nargs=1,
   metavar="linthresh", help='symmetric log scale, specify linear'
   'range limits')

#ey mode
  ey = subparsers.add_parser('ey',help="Analyze ey")
  ey.set_defaults(imgfunc=ey_image)
  ey.add_argument('--clim', dest='limits', type=float, nargs=2,
   metavar=("cmin", "cmax"), help='limits of colour axis')
  ey.add_argument('--slogscale', dest='slogscale', type=float, nargs=1,
   metavar="linthresh", help='symmetric log scale, specify linear'
   'range limits')

#x-Px phase space mode
  xpx = subparsers.add_parser('x_px_phase', help="x - px phase space")
  xpx.set_defaults(imgfunc=x_px_phase_image)
  xpx.add_argument('--species',default='electron',
    help="Species for phase space")
  xpx.add_argument('--xrange', '-x', dest='xrange', type=float, nargs=2,
    metavar=("xmin","xmax"), help="restrict x to range from xmin to xmax")
  xpx.add_argument('--yrange', '-y', dest='yrange', type=float, nargs=2,
    metavar=("ymin","ymax"), help="restrict y to range from xmin to xmax")
  

  return(parser.parse_args())

def debug(*debuginfo):
  if args.verbose:
    print(''.join(map(str,debuginfo)))

def clamp(val, minval, maxval):
  return(max(min(val,maxval),minval))

def window_clip(x,y,var):
  debug("window.shape:x,y,var",x.shape,y.shape,var.shape)
  if args.clip:
    xRatioMin, xRatioMax, yRatioMin, yRatioMax = \
      [clamp(j,0,1) for j in args.clip]
  else:
    xRatioMin, xRatioMax, yRatioMin, yRatioMax = (0.0,1.0,0.0,1.0)
  
  xArgMin = int(xRatioMin * x.shape[0])
  xArgMax = int(xRatioMax * x.shape[0])
  yArgMin = int(yRatioMin * y.shape[0])
  yArgMax = int(yRatioMax * y.shape[0])

  debug("x,y argmin,max",xArgMin,xArgMax,yArgMin,yArgMax)

  return(x[xArgMin:xArgMax],y[yArgMin:yArgMax],
    var[xArgMin:xArgMax,yArgMin:yArgMax])
 
def x_px_phase_image(filename, outputPrefix='', outputDir=''):

  FileInUse = ec.check_file_in_use(filename)
  if FileInUse:
    print("{0} in use by PID {1}, skipping".format(filename,FileInUse))
    return
  elif os.path.exists(os.path.join(os.getcwd(),outputDir,''.join((filename[:-4],'.png')))):
    print("{0} already analyzed, skipping".format(filename))
    return
  else:
    print("Analyzing {0}".format(filename))

  try:
    filedata = sdf.SDF(filename).read()
    x = filedata['Grid/Particles/{0}/X'.format(args.species)]
    y = filedata['Grid/Particles/{0}/Y'.format(args.species)]
    px = filedata['Particles/Px/{0}'.format(args.species)]
  except:
    print("Problem analyzing {0}, file corrupted or missing data".format(filename))
    return

  rangelim = None
  if args.xrange:
    rangelim1 = np.argwhere(x<args.xrange[0])
    rangelim2 = np.argwhere(x>args.xrange[1])
    rangelim = np.intersect1d(rangelim1,rangelim2)
  if args.yrange:
    rangelim1 = np.argwhere(y<args.yrange[0])
    rangelim2 = np.argwhere(y>args.yrange[1])
    rangelim3 = np.intersect1d(rangelim1,rangelim2)
    rangelim = np.intersect1d(rangelim,rangelim3) if rangelim else rangelim3

  x = x[rangelim] if rangelim else x
  y = y[rangelim] if rangelim else y
  px = px[rangelim] if rangelim else px

  plt.figure()
  ax = []
  ax.append(plt.subplot2grid((1,1), (0,0)))
  print(x.shape)	
  print(px.shape)	
  im = []
  im.append(ax[0].plot(x, px, 'k.'))
  x_px = args.ires[0] if args.ires else 1920
  y_px = args.ires[1] if args.ires else 1080
  y_size=10
  x_size=y_size*x_px / y_px
  plt.gcf().set_size_inches(x_size,y_size)
  savepath = os.path.join(outputDir,(''.join((outputPrefix,filename[:-4]))))
  plt.savefig(savepath,dpi=x_px/x_size)
  plt.close()
 

def ex_image(filename, outputPrefix='', outputDir=''):

  FileInUse = ec.check_file_in_use(filename)
  if FileInUse:
    print("{0} in use by PID {1}, skipping".format(filename,FileInUse))
    return
  elif os.path.exists(os.path.join(os.getcwd(),outputDir,''.join((filename[:-4],'.png')))):
    print("{0} already analyzed, skipping".format(filename))
    return
  else:
    print("Analyzing {0}".format(filename))

  try:
    filedata = sdf.SDF(filename).read()
    x = filedata['Grid/Grid/X']
    y = filedata['Grid/Grid/Y']
    ex = filedata['Electric Field/Ex'].transpose()
  except:
    print("Problem analyzing {0}, file corrupted or missing data".format(filename))
    return


  cmin = args.limits[0] if args.limits else ex.min()
  cmax = args.limits[1] if args.limits else ex.max()

  if args.slogscale:
    normalise=SymLogNorm(args.slogscale[0])
  else:
    normalise=None

  plt.figure()
  ax = []
  ax.append(plt.subplot2grid((1,1), (0,0)))
	
  im = []
  im.append(ax[0].imshow(ex, vmin=cmin, vmax=cmax, norm=normalise,
    cmap=plt.get_cmap('CMRmap'), extent=[x.min(), x.max(), y.min(), y.max()],
    aspect='auto'))

  divider = make_axes_locatable(ax[0])
  cax = divider.append_axes('right', size='5%', pad=0.05)
  plt.colorbar(im[0], cax=cax)
  x_px = args.ires[0] if args.ires else 1920
  y_px = args.ires[1] if args.ires else 1080
  y_size=10
  x_size=y_size*x_px / y_px
  plt.gcf().set_size_inches(x_size,y_size)
  savepath = os.path.join(outputDir,(''.join((outputPrefix,filename[:-4]))))
  plt.savefig(savepath,dpi=x_px/x_size)
  plt.close()

def ey_image(filename, outputPrefix='', outputDir=''):

  FileInUse = ec.check_file_in_use(filename)
  if FileInUse:
    print("{0} in use by PID {1}, skipping".format(filename,FileInUse))
    return
  elif os.path.exists(os.path.join(os.getcwd(),outputDir,''.join((filename[:-4],'.png')))):
    print("{0} already analyzed, skipping".format(filename))
    return
  else:
    print("Analyzing {0}".format(filename))

  try:
    filedata = sdf.SDF(filename).read()
    x = filedata['Grid/Grid/X']
    y = filedata['Grid/Grid/Y']
    ey = filedata['Electric Field/Ey'].transpose()
  except:
    print("Problem analyzing {0}, file corrupted or missing data".format(filename))
    return

  cmin = args.limits[0] if args.limits else ey.min()
  cmax = args.limits[1] if args.limits else ey.max()
  
  if args.slogscale:
    normalise=SymLogNorm(args.slogscale[0])
  else:
    normalise=None

  plt.figure()
  ax = []
  ax.append(plt.subplot2grid((1,1), (0,0)))
	
  im = []
  im.append(ax[0].imshow(ey, vmin=cmin, vmax=cmax, norm=normalise,
    cmap=plt.get_cmap('CMRmap'), extent=[x.min(), x.max(), y.min(), y.max()], 
    aspect='auto'))

  divider = make_axes_locatable(ax[0])
  cax = divider.append_axes('right', size='5%', pad=0.05)
  plt.colorbar(im[0], cax=cax)
  x_px = args.ires[0] if args.ires else 1920
  y_px = args.ires[1] if args.ires else 1080
  y_size=10
  x_size=y_size*x_px / y_px
  plt.gcf().set_size_inches(x_size,y_size)
  savepath = os.path.join(outputDir,(''.join((outputPrefix,filename[:-4]))))
  plt.savefig(savepath,dpi=x_px/x_size)
  plt.close()


def density_image(filename, outputPrefix='', outputDir=''):

  FileInUse = ec.check_file_in_use(filename)
  savepath = os.path.join(outputDir,(''.join((outputPrefix,filename[:-4]))))
  if FileInUse:
    print("{0} in use by PID {1}, skipping".format(filename,FileInUse))
    return(None)
  elif os.path.exists(os.path.join(os.getcwd(),''.join((savepath,'.png')))):
    print("{0} already analyzed, skipping".format(filename))
    return(None)
  else:
    print("Analyzing {0}".format(filename))

  try:
    filedata = sdf.SDF(filename).read()
    x = filedata['Grid/Grid/X']
    y = filedata['Grid/Grid/Y']
    dens = filedata['Derived/Number_Density/electron']

  except:
    print("Problem analyzing {0}, file corrupted or missing data".format(filename))
    return(None)

  x, y, dens = window_clip(x,y,dens)

  safeMin = dens.min() if dens.min() > 1e10 else 1e10
  cmin = args.limits[0] if args.limits else safeMin
  cmax = args.limits[1] if args.limits else dens.max()

  plt.figure()
  ax = []
  ax.append(plt.subplot2grid((1,1), (0,0)))

  if args.logscale:
    normalise=LogNorm()
  else:
    normalise=None

  im = []
  im.append(ax[0].imshow(dens.transpose(), vmin=cmin, vmax=cmax,
    norm=normalise, cmap=plt.get_cmap('CMRmap'), 
    extent=[x.min(), x.max(), y.min(), y.max()], aspect='auto'))

  divider = make_axes_locatable(ax[0])
  cax = divider.append_axes('right', size='5%', pad=0.05)
  plt.colorbar(im[0], cax=cax)
  x_px = args.ires[0] if args.ires else 1920
  y_px = args.ires[1] if args.ires else 1080
  y_size=10
  x_size=y_size*x_px / y_px
  plt.gcf().set_size_inches(x_size,y_size)
  plt.savefig(savepath,dpi=x_px/x_size)
  plt.close()

  return(savepath)


def movie_mode():

  prefix = ''
  if args.outputPrefix:
    prefix = args.outputPrefix

  output = args.mode
  if args.outputDir:
    output = args.outputDir


  if args.freshen == True:
    print("Re-analyzing all files...")
    ec.force_mkdir(output) 
  else:
    print("Analyzing new files...")
    ec.mkdir(output)
 
  sdfList = [f for f in os.listdir(os.getcwd()) if f.endswith('.sdf')]

  if args.exclude:
    for pattern in args.exclude:
      try:
        eP = re.compile(pattern)
      except:
        print("Skipping invalid regex pattern {0}".format(pattern))
        continue
      for sdfFile in sdfList:
        if eP.search(sdfFile):
          sdfList.remove(sdfFile)
  
  processor = functools.partial(args.imgfunc,outputPrefix=prefix,
    outputDir=output)
  
  worker_pool = mp.Pool(processes=args.procs)
  frames = worker_pool.map(processor, sdfList)
  #frames = map(args.imgfunc, sdfList)
  newframes = filter(None, frames)
  if newframes:
    if spawn.find_executable('avconv'):
      converter = spawn.find_executable('avconv')
    elif spawn.find_executable('ffmpeg'):
      converter = spawn.find_executable('ffmpeg')
    else:
      print("Couldn't find ffmpeg/avconv :(\n"
            "you're on your own for making the movie")
      sys.exit(1)

    conv_args = [converter,'-r', '5', '-i',
      '{0}/{1}%04d.png'.format(output,prefix), '-c:v', 'libx264', '-r', '25',
      '-pix_fmt', 'yuv420p','-y', 
      ''.join((os.path.basename(os.getcwd()),'_{0}.mp4'.format(output)))]
    spawn.spawn(conv_args)
  else:
    print("No new files, skipping movie creation")


def single_mode():
 
  prefix = ''
  if args.outputPrefix:
    prefix = args.outputPrefix

  output = args.mode
  if args.outputDir:
    output = args.outputDir

  processor = functools.partial(args.imgfunc,outputPrefix=prefix,
    outputDir=output)
 
  singleFile = {True:args.single,
    False:''.join((args.single,'.sdf'))}[args.single.endswith('.sdf')]

  if not os.path.exists(os.path.join(os.getcwd(),singleFile)):
    print("File {0} does not exist!".format(singleFile))

  if not os.path.exists(os.path.join(os.getcwd(),output,
    ''.join((prefix,singleFile)))) or args.freshen:
    image = processor(singleFile)
  else:
    print("{0} exists, use -f to force overwrite".format(''.join((prefix,
      singleFile))))
    

def main():

  global args
  args = argument_parse()

  if args.single:
    single_mode()
  else:
    movie_mode()

if __name__ == '__main__':
  main()
